<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PONG NEXUS â€“ Computer Graphics Project</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }

        #gameWrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #hud {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 900px;
            max-width: 98vw;
            padding: 8px 16px;
            color: #fff;
            font-size: 0.7rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
        }

        #hud .score-block {
            text-align: center;
            min-width: 120px;
        }

        #hud .score-block .name {
            font-size: 0.62rem;
            opacity: 0.5;
            margin-bottom: 2px;
        }

        #hud .score-block .pts {
            font-size: 2rem;
            font-weight: bold;
            line-height: 1;
        }

        #hud .center-block {
            text-align: center;
            font-size: 0.6rem;
            opacity: 0.45;
        }

        #hud .level-tag {
            font-size: 0.55rem;
            padding: 3px 8px;
            border-radius: 10px;
            margin-top: 4px;
        }

        canvas {
            display: block;
            border: 1px solid rgba(255, 255, 255, 0.08);
            cursor: none;
        }

        #overlay {
            position: absolute;
            top: 40px;
            left: 0;
            right: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 10;
        }

        #msg {
            font-family: 'Courier New', monospace;
            font-size: 2.8rem;
            font-weight: bold;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 0 0 30px currentColor;
            text-align: center;
            line-height: 1.2;
        }

        #subMsg {
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.45);
            margin-top: 12px;
            text-align: center;
        }

        #bottomBar {
            width: 900px;
            max-width: 98vw;
            display: flex;
            justify-content: space-between;
            padding: 6px 16px;
            font-size: 0.58rem;
            letter-spacing: 0.1em;
            color: rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
        }

        #powerupBar {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .pu-icon {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            opacity: 0.5;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: opacity 0.3s;
        }

        .pu-icon.active {
            opacity: 1;
            border-color: rgba(255, 255, 255, 0.5);
        }

        #diffBar {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .diff-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.4);
            font-family: 'Courier New', monospace;
            font-size: 0.55rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            padding: 3px 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .diff-btn:hover,
        .diff-btn.active {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.5);
            color: #fff;
        }
    </style>
</head>

<body>

    <div id="gameWrapper">
        <div id="hud">
            <div class="score-block" id="playerHud">
                <div class="name">You</div>
                <div class="pts" id="playerScore">0</div>
                <div id="playerPower" style="font-size:0.6rem;opacity:0.5;margin-top:2px;height:14px;"></div>
            </div>
            <div class="center-block">
                <div id="roundLabel">Round 1</div>
                <div id="ballSpeedLabel" style="margin-top:3px;">Speed: â€“</div>
            </div>
            <div class="score-block" id="cpuHud">
                <div class="name">CPU</div>
                <div class="pts" id="cpuScore">0</div>
                <div id="cpuPower" style="font-size:0.6rem;opacity:0.5;margin-top:2px;height:14px;"></div>
            </div>
        </div>

        <canvas id="canvas"></canvas>

        <div id="overlay">
            <div id="msg"></div>
            <div id="subMsg"></div>
        </div>

        <div id="bottomBar">
            <div id="diffBar">
                Difficulty:
                <button class="diff-btn" onclick="setDiff('easy')">Easy</button>
                <button class="diff-btn active" onclick="setDiff('medium')">Medium</button>
                <button class="diff-btn" onclick="setDiff('hard')">Hard</button>
                <button class="diff-btn" onclick="setDiff('insane')">Insane</button>
            </div>
            <div style="opacity:0.4;">W/S or Mouse Â· First to 7 wins</div>
            <div id="powerupBar">
                Power-ups:
                <div class="pu-icon" id="pu1" title="Big Paddle">ğŸ”µ</div>
                <div class="pu-icon" id="pu2" title="Speed Boost">âš¡</div>
                <div class="pu-icon" id="pu3" title="Shrink CPU">ğŸ”´</div>
                <div class="pu-icon" id="pu4" title="Multi-ball">âœ¦</div>
            </div>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  SETUP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        const W = 900, H = 550;
        canvas.width = W;
        canvas.height = H;

        const WIN_SCORE = 7;
        const PADDLE_W = 12;
        const PADDLE_H = 90;

        // â”€â”€ Difficulty configs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        const DIFFS = {
            easy: { aiSpeed: 2.8, aiReact: 0.04, ballSpd: 5, label: 'EASY', color: '#44ff88' },
            medium: { aiSpeed: 4.2, aiReact: 0.07, ballSpd: 6.5, label: 'MEDIUM', color: '#ffdd44' },
            hard: { aiSpeed: 5.8, aiReact: 0.12, ballSpd: 8, label: 'HARD', color: '#ff8844' },
            insane: { aiSpeed: 8.0, aiReact: 0.22, ballSpd: 10, label: 'INSANE', color: '#ff4466' },
        };
        let currentDiff = 'medium';
        let diff = DIFFS[currentDiff];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let state = 'start'; // 'start' | 'playing' | 'paused' | 'point' | 'over'
        let playerScore = 0, cpuScore = 0, round = 1;
        let keys = {};
        let mouseY = H / 2;
        let frameCount = 0;

        // Paddles
        let player = { x: 30, y: H / 2 - PADDLE_H / 2, w: PADDLE_W, h: PADDLE_H, color: '#00e5ff', score: 0, power: null, powerTimer: 0 };
        let cpu = { x: W - 30 - PADDLE_W, y: H / 2 - PADDLE_H / 2, w: PADDLE_W, h: PADDLE_H, color: '#ff4081', score: 0, power: null, powerTimer: 0 };

        // Balls
        let balls = [];

        // Particles
        let particles = [];

        // Power-ups on field
        let powerups = [];

        // Trail effect for ball
        let trails = [];

        // Screen flash
        let flash = { alpha: 0, color: '#fff' };

        // AI state
        let aiTarget = H / 2;
        let aiPredictX = W / 2;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  BALL FACTORY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function makeBall(toPlayer) {
            const angle = (Math.random() * 60 - 30) * Math.PI / 180;
            const dir = toPlayer ? -1 : 1;
            const spd = diff.ballSpd + round * 0.3;
            return {
                x: W / 2, y: H / 2,
                vx: Math.cos(angle) * spd * dir,
                vy: Math.sin(angle) * spd,
                r: 9,
                color: '#ffffff',
                glow: '#ffffff',
                spin: 0,
                trail: []
            };
        }

        function resetBalls(toPlayer) {
            balls = [makeBall(toPlayer !== undefined ? toPlayer : Math.random() < 0.5)];
            trails = [];
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  POWERUP FACTORY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const PU_TYPES = [
            { id: 'big', emoji: 'ğŸ”µ', label: 'Big Paddle', color: '#00aaff', duration: 8000 },
            { id: 'speed', emoji: 'âš¡', label: 'Speed Boost', color: '#ffee00', duration: 6000 },
            { id: 'shrink', emoji: 'ğŸ”´', label: 'Shrink CPU', color: '#ff3355', duration: 8000 },
            { id: 'multiball', emoji: 'âœ¦', label: 'Multi-Ball', color: '#cc88ff', duration: 0 },
        ];

        function spawnPowerup() {
            if (powerups.length >= 2) return;
            const type = PU_TYPES[Math.floor(Math.random() * PU_TYPES.length)];
            powerups.push({
                x: W / 2 + (Math.random() - 0.5) * 200,
                y: 80 + Math.random() * (H - 160),
                r: 14,
                type,
                pulse: 0,
                alive: true
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  PARTICLE SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function burst(x, y, color, count = 18, speed = 6) {
            for (let i = 0; i < count; i++) {
                const a = Math.random() * Math.PI * 2;
                const s = Math.random() * speed + 1;
                particles.push({
                    x, y,
                    vx: Math.cos(a) * s, vy: Math.sin(a) * s,
                    life: 1, decay: 0.02 + Math.random() * 0.03,
                    size: 2 + Math.random() * 4,
                    color
                });
            }
        }

        function scoreBurst(x, y, color) {
            burst(x, y, color, 40, 10);
            for (let i = 0; i < 15; i++) {
                const a = Math.random() * Math.PI * 2;
                particles.push({
                    x, y,
                    vx: Math.cos(a) * (Math.random() * 4 + 2),
                    vy: Math.sin(a) * (Math.random() * 4 + 2),
                    life: 1, decay: 0.008 + Math.random() * 0.01,
                    size: 3 + Math.random() * 8,
                    color: `hsl(${Math.random() * 60 + 20},100%,70%)`
                });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  PHYSICS & LOGIC
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function updateBall(ball, idx) {
            // Trail
            ball.trail.push({ x: ball.x, y: ball.y });
            if (ball.trail.length > 12) ball.trail.shift();

            ball.x += ball.vx;
            ball.y += ball.vy;

            // Wall bounce top/bottom
            if (ball.y - ball.r <= 0) {
                ball.y = ball.r;
                ball.vy = Math.abs(ball.vy);
                burst(ball.x, 0, '#aaffee', 6, 3);
            }
            if (ball.y + ball.r >= H) {
                ball.y = H - ball.r;
                ball.vy = -Math.abs(ball.vy);
                burst(ball.x, H, '#aaffee', 6, 3);
            }

            // Paddle collision helper
            function paddleHit(paddle, isPlayer) {
                if (ball.x - ball.r < paddle.x + paddle.w &&
                    ball.x + ball.r > paddle.x &&
                    ball.y - ball.r < paddle.y + paddle.h &&
                    ball.y + ball.r > paddle.y) {

                    // Prevent sticking
                    if (isPlayer) ball.x = paddle.x + paddle.w + ball.r;
                    else ball.x = paddle.x - ball.r;

                    const hitPos = (ball.y - (paddle.y + paddle.h / 2)) / (paddle.h / 2);
                    const angle = hitPos * (Math.PI / 3); // max 60Â°
                    const spd = Math.hypot(ball.vx, ball.vy) * 1.04;
                    const capped = Math.min(spd, diff.ballSpd * 2.5);
                    const dir = isPlayer ? 1 : -1;

                    ball.vx = Math.cos(angle) * capped * dir;
                    ball.vy = Math.sin(angle) * capped;
                    ball.spin = hitPos * 3;
                    ball.color = isPlayer ? '#00e5ff' : '#ff4081';
                    ball.glow = isPlayer ? '#00e5ff' : '#ff4081';

                    // Speed boost power-up
                    if (isPlayer && player.power === 'speed') {
                        ball.vx *= 1.3;
                        ball.vy *= 1.3;
                    }

                    burst(ball.x, ball.y, ball.color, 12, 4);
                    flash.alpha = 0.12;
                    flash.color = ball.color;
                    return true;
                }
                return false;
            }

            paddleHit(player, true);
            paddleHit(cpu, false);

            // Score
            if (ball.x + ball.r < 0) {
                cpuScore++;
                scoreEvent('cpu', ball);
                if (idx === 0) endPoint('cpu');
                return false; // remove ball
            }
            if (ball.x - ball.r > W) {
                playerScore++;
                scoreEvent('player', ball);
                if (idx === 0) endPoint('player');
                return false;
            }

            // Power-up collection
            for (let i = powerups.length - 1; i >= 0; i--) {
                const pu = powerups[i];
                if (Math.hypot(ball.x - pu.x, ball.y - pu.y) < ball.r + pu.r) {
                    applyPowerup(pu.type, ball.vx < 0 ? 'cpu' : 'player');
                    burst(pu.x, pu.y, pu.type.color, 25, 7);
                    flash.alpha = 0.2;
                    flash.color = pu.type.color;
                    powerups.splice(i, 1);
                }
            }

            return true;
        }

        function scoreEvent(who, ball) {
            const x = who === 'player' ? W - 60 : 60;
            scoreBurst(x, H / 2, who === 'player' ? '#00e5ff' : '#ff4081');
            flash.alpha = 0.35;
            flash.color = who === 'player' ? '#00e5ff' : '#ff4081';
        }

        function endPoint(scorer) {
            state = 'point';
            updateScoreHUD();
            setTimeout(() => {
                if (playerScore >= WIN_SCORE || cpuScore >= WIN_SCORE) {
                    endGame(scorer);
                } else {
                    round++;
                    startPoint(scorer === 'cpu');
                }
            }, 1200);
        }

        function startPoint(toPlayer) {
            powerups = [];
            resetBalls(toPlayer);
            state = 'playing';
            document.getElementById('roundLabel').textContent = `Round ${round}`;
            document.getElementById('msg').textContent = '';
            document.getElementById('subMsg').textContent = '';
        }

        function endGame(scorer) {
            state = 'over';
            const won = scorer === 'player';
            document.getElementById('msg').style.color = won ? '#00e5ff' : '#ff4081';
            document.getElementById('msg').textContent = won ? 'YOU WIN!' : 'CPU WINS';
            document.getElementById('subMsg').textContent = `Final Score  ${playerScore} â€“ ${cpuScore}   Â·   Press SPACE to replay`;
        }

        // â”€â”€â”€ Power-up application â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function applyPowerup(type, who) {
            const pad = who === 'player' ? player : cpu;
            const other = who === 'player' ? cpu : player;
            clearTimeout(pad._puTimeout);

            if (type.id === 'big') {
                pad.h = 140;
                pad.power = 'big';
                pad._puTimeout = setTimeout(() => { pad.h = PADDLE_H; pad.power = null; }, type.duration);
            } else if (type.id === 'speed') {
                pad.power = 'speed';
                pad._puTimeout = setTimeout(() => { pad.power = null; }, type.duration);
            } else if (type.id === 'shrink') {
                other.h = 50;
                other._puTimeout = setTimeout(() => { other.h = PADDLE_H; }, type.duration);
            } else if (type.id === 'multiball') {
                for (let i = 0; i < 2; i++) balls.push(makeBall(Math.random() < 0.5));
            }

            showPowerLabel(who, type.emoji + ' ' + type.label);
        }

        function showPowerLabel(who, text) {
            const el = document.getElementById(who === 'player' ? 'playerPower' : 'cpuPower');
            el.textContent = text;
            clearTimeout(el._t);
            el._t = setTimeout(() => { el.textContent = ''; }, 4000);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  AI LOGIC
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function updateAI() {
            if (balls.length === 0) return;

            // Predict where primary ball will be when it reaches CPU paddle
            const b = balls[0];
            let predictY = b.y;

            if (b.vx > 0) {
                const timeToReach = (cpu.x - b.x) / b.vx;
                predictY = b.y + b.vy * timeToReach;
                // Bounce prediction
                const bounces = Math.abs(Math.floor(predictY / H));
                predictY = predictY % H;
                if (bounces % 2 !== 0) predictY = H - Math.abs(predictY);
                predictY = Math.max(0, Math.min(H, predictY));
                // Add imperfection scaled by difficulty
                const err = (1 - diff.aiReact * 5) * 60;
                predictY += (Math.random() - 0.5) * err;
            } else {
                // Ball coming at player â€“ CPU returns to center with slight randomness
                predictY = H / 2 + (Math.random() - 0.5) * 80;
            }

            aiTarget = lerp(aiTarget, predictY, diff.aiReact);

            // Move CPU paddle
            const cpuCenter = cpu.y + cpu.h / 2;
            const delta = aiTarget - cpuCenter;
            const step = Math.min(Math.abs(delta), diff.aiSpeed);
            cpu.y += Math.sign(delta) * step;

            // Clamp
            cpu.y = Math.max(0, Math.min(H - cpu.h, cpu.y));
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  PLAYER CONTROLS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const PLAYER_SPEED = 7;

        function updatePlayer() {
            if (keys['w'] || keys['W'] || keys['ArrowUp']) player.y -= PLAYER_SPEED;
            if (keys['s'] || keys['S'] || keys['ArrowDown']) player.y += PLAYER_SPEED;

            // Mouse control
            const target = mouseY - player.h / 2;
            player.y = lerp(player.y, target, 0.18);

            player.y = Math.max(0, Math.min(H - player.h, player.y));
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  DRAWING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â”€â”€ Background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function drawBackground() {
            // Base
            ctx.fillStyle = '#030b14';
            ctx.fillRect(0, 0, W, H);

            // Grid
            ctx.strokeStyle = 'rgba(0,200,255,0.04)';
            ctx.lineWidth = 1;
            const gs = 40;
            for (let x = 0; x <= W; x += gs) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke();
            }
            for (let y = 0; y <= H; y += gs) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
            }

            // Center line dashes
            ctx.setLineDash([12, 10]);
            ctx.strokeStyle = 'rgba(255,255,255,0.08)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(W / 2, 0);
            ctx.lineTo(W / 2, H);
            ctx.stroke();
            ctx.setLineDash([]);

            // Center circle
            ctx.beginPath();
            ctx.arc(W / 2, H / 2, 55, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255,255,255,0.05)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Corner arcs
            [
                [0, 0], [W, 0], [0, H], [W, H]
            ].forEach(([cx, cy]) => {
                ctx.beginPath();
                ctx.arc(cx, cy, 60, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            // Vignette
            const vig = ctx.createRadialGradient(W / 2, H / 2, H * 0.3, W / 2, H / 2, H * 0.85);
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(0,0,0,0.55)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, W, H);
        }

        // â”€â”€ Screen flash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function drawFlash() {
            if (flash.alpha <= 0) return;
            ctx.fillStyle = flash.color.replace(')', `,${flash.alpha})`).replace('#',
                flash.color.length === 7 ? 'rgba(' + parseInt(flash.color.slice(1, 3), 16) + ','
                    + parseInt(flash.color.slice(3, 5), 16) + ','
                    + parseInt(flash.color.slice(5, 7), 16) + ',' : '#');
            // Simpler approach:
            ctx.save();
            ctx.globalAlpha = flash.alpha;
            ctx.fillStyle = flash.color;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
            flash.alpha = Math.max(0, flash.alpha - 0.025);
        }

        // â”€â”€ Paddle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function drawPaddle(pad) {
            const x = pad.x, y = pad.y, w = pad.w, h = pad.h;
            const c = pad.color;

            // Glow
            ctx.save();
            ctx.shadowColor = c;
            ctx.shadowBlur = pad.power ? 30 : 16;

            // Body gradient
            const grad = ctx.createLinearGradient(x, y, x + w, y);
            grad.addColorStop(0, c);
            grad.addColorStop(0.5, lighten(c, 0.4));
            grad.addColorStop(1, c);

            roundRect(ctx, x, y, w, h, 5);
            ctx.fillStyle = grad;
            ctx.fill();

            // Power glow ring
            if (pad.power) {
                ctx.strokeStyle = pad.power === 'big' ? '#00aaff'
                    : pad.power === 'speed' ? '#ffee00' : '#ff3355';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 20;
                ctx.stroke();
            }

            ctx.restore();

            // Edge highlight
            ctx.beginPath();
            ctx.moveTo(x + w / 2, y + 3);
            ctx.lineTo(x + w / 2, y + h - 3);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // â”€â”€ Ball â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function drawBall(ball) {
            // Trail
            for (let i = 0; i < ball.trail.length; i++) {
                const t = ball.trail[i];
                const a = i / ball.trail.length;
                const r = ball.r * a * 0.75;
                ctx.beginPath();
                ctx.arc(t.x, t.y, r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${hexToRgb(ball.glow)},${a * 0.4})`;
                ctx.fill();
            }

            // Glow halo
            const grad = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.r * 3);
            grad.addColorStop(0, `rgba(${hexToRgb(ball.glow)},0.35)`);
            grad.addColorStop(1, `rgba(${hexToRgb(ball.glow)},0)`);
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r * 3, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();

            // Core
            ctx.save();
            ctx.shadowColor = ball.glow;
            ctx.shadowBlur = 18;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.restore();

            // Spin indicator line
            ctx.save();
            ctx.translate(ball.x, ball.y);
            ctx.rotate(frameCount * ball.spin * 0.05);
            ctx.strokeStyle = `rgba(${hexToRgb(ball.color)},0.6)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(-ball.r * 0.6, 0);
            ctx.lineTo(ball.r * 0.6, 0);
            ctx.stroke();
            ctx.restore();
        }

        // â”€â”€ Power-ups on field â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function drawPowerups() {
            const now = Date.now();
            for (const pu of powerups) {
                pu.pulse += 0.06;
                const scale = 1 + Math.sin(pu.pulse) * 0.12;

                ctx.save();
                ctx.translate(pu.x, pu.y);
                ctx.scale(scale, scale);

                // Orbit ring
                ctx.beginPath();
                ctx.arc(0, 0, pu.r + 6, 0, Math.PI * 2);
                ctx.strokeStyle = pu.type.color + '66';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // Rotating dash
                ctx.save();
                ctx.rotate(pu.pulse);
                ctx.setLineDash([4, 8]);
                ctx.beginPath();
                ctx.arc(0, 0, pu.r + 6, 0, Math.PI * 2);
                ctx.strokeStyle = pu.type.color;
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.restore();

                // Glow
                ctx.save();
                ctx.shadowColor = pu.type.color;
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(0, 0, pu.r, 0, Math.PI * 2);
                ctx.fillStyle = pu.type.color + 'aa';
                ctx.fill();
                ctx.restore();

                // Emoji
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pu.type.emoji, 0, 0);

                ctx.restore();
            }
        }

        // â”€â”€ Particles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function drawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.94;
                p.vy *= 0.94;
                p.life -= p.decay;
                if (p.life <= 0) { particles.splice(i, 1); continue; }

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // â”€â”€ Score HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function updateScoreHUD() {
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('cpuScore').textContent = cpuScore;
            if (balls[0]) {
                const spd = Math.hypot(balls[0].vx, balls[0].vy).toFixed(1);
                document.getElementById('ballSpeedLabel').textContent = `Speed: ${spd}`;
            }
        }

        // â”€â”€ Scanline overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        function drawScanlines() {
            ctx.save();
            for (let y = 0; y < H; y += 3) {
                ctx.fillStyle = 'rgba(0,0,0,0.06)';
                ctx.fillRect(0, y, W, 1);
            }
            ctx.restore();
        }

        // â”€â”€â”€ Countdown flash for round start â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        let countdownVal = 0;
        let countdownAlpha = 0;

        function showCountdown(n, cb) {
            countdownVal = n;
            countdownAlpha = 1;
            const iv = setInterval(() => {
                countdownVal--;
                countdownAlpha = 1;
                if (countdownVal <= 0) { clearInterval(iv); cb(); }
            }, 900);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  MAIN LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let lastPowerupSpawn = 0;

        function loop() {
            frameCount++;
            requestAnimationFrame(loop);

            drawBackground();

            if (state === 'playing') {
                updatePlayer();
                updateAI();

                // Spawn power-ups periodically
                if (frameCount - lastPowerupSpawn > 300 + Math.random() * 200) {
                    spawnPowerup();
                    lastPowerupSpawn = frameCount;
                }

                // Update balls
                for (let i = balls.length - 1; i >= 0; i--) {
                    const alive = updateBall(balls[i], i);
                    if (!alive) balls.splice(i, 1);
                }

                updateScoreHUD();
            }

            // Draw powerups
            drawPowerups();

            // Draw paddles
            drawPaddle(player);
            drawPaddle(cpu);

            // Draw balls
            for (const b of balls) drawBall(b);

            // Particles
            drawParticles();

            // Flash
            drawFlash();

            // Countdown
            if (countdownAlpha > 0) {
                countdownAlpha -= 0.018;
                ctx.save();
                ctx.globalAlpha = Math.max(0, countdownAlpha);
                ctx.font = 'bold 110px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = diff.color;
                ctx.shadowColor = diff.color;
                ctx.shadowBlur = 50;
                ctx.fillText(countdownVal > 0 ? countdownVal : 'GO!', W / 2, H / 2);
                ctx.restore();
            }

            drawScanlines();

            // Win line indicators
            ctx.save();
            const pRatio = playerScore / WIN_SCORE;
            const cRatio = cpuScore / WIN_SCORE;
            ctx.fillStyle = `rgba(0,229,255,0.15)`;
            ctx.fillRect(0, H - 4, W / 2 * pRatio, 4);
            ctx.fillStyle = `rgba(255,64,129,0.15)`;
            ctx.fillRect(W - W / 2 * cRatio, H - 4, W / 2 * cRatio, 4);
            ctx.restore();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  START / RESTART
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function startGame() {
            playerScore = 0; cpuScore = 0; round = 1;
            player.y = H / 2 - PADDLE_H / 2;
            player.h = PADDLE_H; player.power = null;
            cpu.y = H / 2 - PADDLE_H / 2;
            cpu.h = PADDLE_H; cpu.power = null;
            particles = []; powerups = []; balls = [];
            diff = DIFFS[currentDiff];
            updateScoreHUD();
            document.getElementById('roundLabel').textContent = 'Round 1';
            document.getElementById('msg').textContent = '';
            document.getElementById('subMsg').textContent = '';

            showCountdown(3, () => {
                resetBalls(Math.random() < 0.5);
                state = 'playing';
            });
        }

        function setDiff(d) {
            currentDiff = d;
            diff = DIFFS[d];
            document.querySelectorAll('.diff-btn').forEach(b => {
                b.classList.toggle('active', b.textContent.toLowerCase() === d);
            });
            if (state !== 'playing') startGame();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  INPUT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if ((e.key === ' ' || e.key === 'Enter') && state !== 'playing') startGame();
            if (e.key === 'p' || e.key === 'P') {
                if (state === 'playing') state = 'paused';
                else if (state === 'paused') state = 'playing';
            }
            e.preventDefault();
        });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseY = (e.clientY - rect.top) * (H / rect.height);
        });

        canvas.addEventListener('click', () => {
            if (state !== 'playing') startGame();
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function lerp(a, b, t) { return a + (b - a) * t; }

        function roundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function lighten(hex, amt) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgb(${Math.min(255, r + amt * 255)},${Math.min(255, g + amt * 255)},${Math.min(255, b + amt * 255)})`;
        }

        function hexToRgb(hex) {
            if (!hex || hex[0] !== '#') return '255,255,255';
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `${r},${g},${b}`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  INIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Show start screen
        document.getElementById('msg').style.color = '#00e5ff';
        document.getElementById('msg').textContent = 'PONG NEXUS';
        document.getElementById('subMsg').textContent = 'Press SPACE or click to start Â· W/S or Mouse to move';

        loop();
    </script>
</body>

</html>